<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>hello there.</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="styles.css" />
  <link rel="icon" href="favicon.png" type="image/png" />
</head>

<body>
  <div class="page">

    <div class="top">
      <header class="site-header">
        <video class="header-image" autoplay muted loop playsinline>
          <source src="assets/icon.webm" type="video/webm">
          <source src="assets/icon.mp4" type="video/mp4">
        </video>
      </header>

      <section class="hero">
        <h1>Bee Nix // Suture Blue</h1>
        <p>Thinking. Creating. Playing.</p>
        <p>Animations. Interactives. Games. Lectures. Discussions.</p>
      </section>
    </div>

    <main>

      <!-- PRACTICE -->
      <section id="practice" class="section">
        <h2>Practice</h2>

        <!-- Carousel -->
        <div class="work-item">
          <div class="glow-card">
            <div class="glow-card-inner">

              <div class="carousel">
                <button class="carousel-btn left" type="button" aria-label="Previous project">‹</button>

                <div class="carousel-stage">
                  <div class="carousel-stack left"></div>

                  <div class="carousel-center" role="button" tabindex="0" aria-label="Open project details">
                    <img class="carousel-center-img" src="assets/gNg.png" alt="">
                  </div>

                  <div class="carousel-stack right"></div>
                </div>

                <button class="carousel-btn right" type="button" aria-label="Next project">›</button>

                <div class="carousel-sources" hidden>
                  <img src="assets/glitchplay.png" data-title="Glitch Play (2025)" data-template=".tpl-glitchplay" alt="">
                  <img src="assets/gNg.png"        data-title="Glitch'N'Games (2024)" data-template=".tpl-gng" alt="">
                  <img src="assets/mfru.png"       data-title="MFRU (2023)" data-template=".tpl-mfru" alt="">
                </div>

                <div class="work-overlay" aria-hidden="true" role="dialog" aria-modal="true">
                  <div class="overlay-inner">
                    <div class="overlay-scroll">
                      <div class="overlay-text"></div>
                    </div>

                    <div class="overlay-actions">
                      <button class="overlay-close" type="button" aria-label="Close overlay">×</button>
                    </div>
                  </div>
                </div>

              </div><!-- /.carousel -->

            </div>
          </div>

          <div class="work-meta">
            <h3 class="project-title"></h3>
          </div>

          <!-- Carousel templates -->
          <template class="tpl-glitchplay">
            <p>
              Glitch Play is my MFA thesis in Interactive Media and Game Development. It investigates engaging with glitches as a form of play that reveals and enables renegotiations with the structure of digital systems.
              You can <a href="https://archive.org/details/glitch_play" target="_blank" rel="noreferrer">read it here.</a>
            </p>
          </template>

          <template class="tpl-gng">
            <p>
              This exhibition explored the intertwined histories of glitch art and video games, featuring 40+ artists from over 5 countries, across two Pittsburgh venues.
            </p>
            <p>
              As producer, curator, and organizer alongside John Bumstead and Nick Liberatore, I developed the show's conceptual framework and programmed workshops, discussions, and live demonstrations.
            </p>
            <p>
              I created and moderated the Discussion Game, a participatory conversation format that gathered artists, theorists, and gamers to explore themes of play, control, and system disruption.
            </p>
          </template>

          <template class="tpl-mfru">
            <p>
              This panel of digital artists was brought together in Maribor, Slovenia to discuss digital archiving for community by community for
              <a href="https://www.mfru.org/events/panel-sustainability-and-autonomy-of-digital-art" target="_blank" rel="noreferrer">MFRU 2023.</a>
            </p>
            <p>
              My IRL contributions to the discussion were not so much about my experience as an artist, but rather as a Do-It-Together (DIT) media archivist who is currently organizing, with a couple others— a free, downloadable, public access digital archive for the Glitch Art community.
            </p>
            <p>
              Those of us working on this project believe that the more you rely on open software, the more accessible an archive becomes. That community projects can operate with more integrity when they remain unaffiliated with any institution(s). And most of all, we actively go against writing any “defining narrative(s),” but rather aim to offer an index of searchable artists and artists’ works, as well as any affiliated history, to enable many narratives to overlap, web and be formed by people of the community, in hopes for a more holistic history to be available to those who care to have it.
            </p>
          </template>
        </div>

        <!-- Reset button BELOW carousel -->
        <div class="practice-controls">
          <button id="practiceReset" class="practice-reset" type="button" aria-label="Reset practice windows" title="Reset">↺</button>
        </div>

        <!-- Starting area BELOW reset -->
        <div id="practiceDesktop" class="practice-desktop" aria-label="Draggable practice windows">
          <!-- windows injected by JS -->
        </div>

        <!-- Practice text templates -->
        <template id="tpl-colourorgan">
          <p><strong>Colour Organ</strong></p>
          <p>Put your description here. Long text will scroll.</p>
        </template>

        <template id="tpl-discussiongame">
          <p><strong>Discussion Game</strong></p>
          <p>Put your description here. Long text will scroll.</p>
        </template>

        <template id="tpl-drawing">
          <p><strong>Drawing</strong></p>
          <p>Put your description here. Long text will scroll.</p>
        </template>

        <template id="tpl-fabrication">
          <p><strong>Fabrication</strong></p>
          <p>Put your description here. Long text will scroll.</p>
        </template>

        <template id="tpl-lightsleeper">
          <p><strong>Light Sleeper</strong></p>
          <p>Put your description here. Long text will scroll.</p>
        </template>

        <template id="tpl-uncanny">
          <p><strong>Uncanny</strong></p>
          <p>Put your description here. Long text will scroll.</p>
        </template>

      </section>

      <!-- About -->
      <section id="about" class="section">
        <h2>About</h2>

        <div class="about-layout">
          <div>
            <p>I’m Bee Nix, aka Suture Blue.</p>
            <p>
              As a system amongst systems, I trace how internal states entangle with
              the larger technosocial worlds by interweaving play, technology, and social structures.
              Time-based and experiential works tend to be what I make the most.
            </p>

            <!-- CV button -->
            <a class="cv-link" href="assets/BeeNix_CV_2026.pdf" target="_blank" rel="noreferrer">View CV</a>
          </div>

          <div class="about-meta">
            <p>
              <strong>Currently</strong><br>
              Residing in Pittsburgh, PA;
              Working in the exhibits department at the Children's Museum as a designer/builder;
              Slowly making this website; Practicing maintaining center; Trying to get Glitch'N'Games 2 going;
              Creating art, curating things, talking to others.
            </p>

            <p>
              <strong>Contact</strong><br>
              sutureblue@protonmail.com
            </p>
          </div>
        </div>
      </section>

    </main>

    <footer class="site-footer">
      <div class="license-footer">
        <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noreferrer">
          <img src="assets/cc.png" alt="Creative Commons" class="cc-icon" />
        </a>
        <span>2025</span>
      </div>

      <span class="footer-note">built by hand · gently under construction</span>
    </footer>

  </div>

  <script>
    /* ---------- Carousel + Overlay (UNCHANGED from your original) ---------- */
    document.querySelectorAll(".work-item").forEach((workItem) => {
      const carousel = workItem.querySelector(".carousel");

      const overlay = workItem.querySelector(".work-overlay");
      const overlayInner = workItem.querySelector(".overlay-inner");
      const overlayScroll = workItem.querySelector(".overlay-scroll");
      const overlayText = workItem.querySelector(".overlay-text");

      const closeBtn = workItem.querySelector(".overlay-close");

      const titleEl = workItem.querySelector(".project-title");

      const centerImg = carousel.querySelector(".carousel-center-img");
      const centerArea = carousel.querySelector(".carousel-center");

      const leftStackEl = carousel.querySelector(".carousel-stack.left");
      const rightStackEl = carousel.querySelector(".carousel-stack.right");

      const btnLeft = carousel.querySelector(".carousel-btn.left");
      const btnRight = carousel.querySelector(".carousel-btn.right");

      let lastFocusEl = null;

      const projects = Array.from(
        carousel.querySelectorAll(".carousel-sources img")
      ).map(img => ({
        src: img.getAttribute("src"),
        title: img.dataset.title || "Untitled",
        template: img.dataset.template || ""
      }));

      let center = 0;
      let leftStack = [];
      let rightStack = projects.map((_, i) => i).slice(1);

      function updateMeta(index) {
        titleEl.textContent = projects[index].title;
        const sel = projects[index].template;
        const tpl = sel ? workItem.querySelector(sel) : null;
        overlayText.innerHTML = tpl ? tpl.innerHTML : "";
      }

      function renderStacks() {
        leftStackEl.innerHTML = "";
        rightStackEl.innerHTML = "";

        leftStack.forEach((idx, i) => {
          const card = document.createElement("div");
          card.className = "stack-card";
          card.style.setProperty("--stack-i", i);
          card.innerHTML = `<img src="${projects[idx].src}" alt="">`;
          leftStackEl.appendChild(card);
        });

        rightStack.forEach((idx, i) => {
          const card = document.createElement("div");
          card.className = "stack-card";
          card.style.setProperty("--stack-i", i);
          card.innerHTML = `<img src="${projects[idx].src}" alt="">`;
          rightStackEl.appendChild(card);
        });

        centerImg.src = projects[center].src;
        updateMeta(center);

        btnLeft.disabled = leftStack.length === 0;
        btnRight.disabled = rightStack.length === 0;
      }

      function goNext() {
        if (!rightStack.length) return;
        leftStack.unshift(center);
        center = rightStack.shift();
        renderStacks();
      }

      function goPrev() {
        if (!leftStack.length) return;
        rightStack.unshift(center);
        center = leftStack.shift();
        renderStacks();
      }

      btnLeft.onclick = goPrev;
      btnRight.onclick = goNext;

      function openOverlay(e) {
        if (e) e.stopPropagation();
        lastFocusEl = document.activeElement;

        overlay.classList.add("active");
        overlay.setAttribute("aria-hidden", "false");
        overlayScroll.scrollTop = 0;

        closeBtn.focus({ preventScroll: true });
      }

      function closeOverlay(e) {
        if (e) e.stopPropagation();
        overlay.classList.remove("active");
        overlay.setAttribute("aria-hidden", "true");
        if (lastFocusEl) lastFocusEl.focus({ preventScroll: true });
      }

      centerArea.onclick = openOverlay;

      centerArea.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") openOverlay(e);
      });

      closeBtn.onclick = closeOverlay;
      overlay.onclick = closeOverlay;
      overlayInner.onclick = (e) => e.stopPropagation();

      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape") closeOverlay(e);
      });

      renderStacks();
    });

/* ---------- Practice Windows
   Desktop: draggable windows + right-splayed randomized zig-zag spawn (like your screenshot)
   Mobile: 2-col grid; close removes tile and grid reflows; reset repopulates.
---------- */
(() => {
  const desktop = document.getElementById("practiceDesktop");
  const resetBtn = document.getElementById("practiceReset");
  if (!desktop || !resetBtn) return;

  const PRACTICE = [
    { id:"colourorgan",    src:"assets/ColourOrgan_1.png",    title:"Colour Organ" },
    { id:"discussiongame", src:"assets/DiscussionGame_1.png", title:"Discussion Game" },
    { id:"drawing",        src:"assets/Drawing_1.png",        title:"Drawing" },
    { id:"fabrication",    src:"assets/Fabrication_1.png",    title:"Fabrication" },
    { id:"lightsleeper",   src:"assets/LightSleeper_1.png",   title:"Light Sleeper" },
    { id:"uncanny",        src:"assets/Uncanny_1.png",        title:"Uncanny" }
  ];

  const mqMobile = window.matchMedia("(max-width: 760px)");
  const isMobile = () => mqMobile.matches;

  let zTop = 10;

  function getTemplateHTML(id) {
    const tpl = document.getElementById(`tpl-${id}`);
    return tpl ? tpl.innerHTML : `<p><strong>${id}</strong></p>`;
  }

  function bringToFront(win) {
    win.style.zIndex = String(++zTop);
  }

  function randBetween(min, max) {
    return min + Math.random() * (max - min);
  }

  function clamp(n, min, max) {
    return Math.max(min, Math.min(max, n));
  }

  // Compute right-splayed zig-zag spawn positions for DESKTOP mode
  function computeSplayPositions(count) {
    // Use known default window dimensions on desktop (your CSS defaults)
    const WIN_W = 300;
    const BAR_H = 34;
    const IMG_H = 250;
    const WIN_H = BAR_H + IMG_H;

    // Ensure desktop has a measurable rect (in case of first load)
    const rect = desktop.getBoundingClientRect();
    const deskW = Math.max(320, rect.width || 320);
    const deskH = Math.max(520, rect.height || 520);

    // You can tune these to taste
    const startX  = 30;
    const startY  = 24;
    const stepX   = 140; // splay right
    const stepY   = 10;  // gentle descent
    const zigAmp  = 26;  // up/down swing
    const jitterX = 14;  // slight hand-placed feel
    const jitterY = 10;

    // bounds: avoid starting in the void
    const minX = 8;
    const minY = 8;
    const maxX = Math.max(minX, Math.floor(deskW - WIN_W - 8));
    const maxY = Math.max(minY, Math.floor(deskH - WIN_H - 8));

    const pos = [];

    for (let i = 0; i < count; i++) {
      const zig = (i % 2 === 0) ? -zigAmp : zigAmp;

      let x = startX + i * stepX + randBetween(-jitterX, jitterX);
      let y = startY + i * stepY + zig + randBetween(-jitterY, jitterY);

      // clamp so they're visible initially
      x = clamp(x, minX, maxX);
      y = clamp(y, minY, maxY);

      pos.push({ x, y });
    }

    return pos;
  }

  function applyDesktopPosition(win) {
    const x = parseFloat(win.dataset.x || "0");
    const y = parseFloat(win.dataset.y || "0");
    win.style.left = x + "px";
    win.style.top  = y + "px";
  }

  function applyMobilePosition(win) {
    // Grid places it; remove absolute offsets
    win.style.left = "";
    win.style.top = "";
  }

  function syncModeClass() {
    if (isMobile()) desktop.classList.add("is-mobile");
    else desktop.classList.remove("is-mobile");

    const wins = Array.from(desktop.querySelectorAll(".pwin"));
    wins.forEach(win => {
      if (isMobile()) applyMobilePosition(win);
      else applyDesktopPosition(win);
    });
  }

  function createWindow(item) {
    const win = document.createElement("div");
    win.className = "pwin";
    win.dataset.id = item.id;
    win.style.zIndex = String(++zTop);

    // placement happens after creation (populate assigns x/y)
    win.innerHTML = `
      <div class="pwin-bar" role="toolbar">
        <button class="pwin-close" type="button" aria-label="Close window">×</button>
        <div class="pwin-title" title="${item.title}">${item.title}</div>
      </div>

      <div class="pwin-body" role="button" tabindex="0" aria-label="Open description">
        <img src="${item.src}" alt="${item.title}">
      </div>

      <div class="pwin-overlay" aria-hidden="true">
        <button class="pwin-min" type="button" aria-label="Minimize description">–</button>
        <div class="pwin-overlay-scroll">
          <div class="pwin-overlay-text"></div>
        </div>
      </div>
    `;

    const bar = win.querySelector(".pwin-bar");
    const close = win.querySelector(".pwin-close");
    const body = win.querySelector(".pwin-body");

    const overlay = win.querySelector(".pwin-overlay");
    const minBtn = win.querySelector(".pwin-min");
    const overlayScroll = win.querySelector(".pwin-overlay-scroll");
    const overlayText = win.querySelector(".pwin-overlay-text");

    function openOverlay(e) {
      if (e) e.stopPropagation();
      bringToFront(win);

      overlayText.innerHTML = getTemplateHTML(item.id);
      overlay.classList.add("active");
      overlay.setAttribute("aria-hidden", "false");
      overlayScroll.scrollTop = 0;

      minBtn.focus({ preventScroll: true });
    }

    function closeOverlay(e) {
      if (e) e.stopPropagation();
      overlay.classList.remove("active");
      overlay.setAttribute("aria-hidden", "true");
    }

    // Close window
    close.addEventListener("click", (e) => {
      e.stopPropagation();

      // In mobile grid, do a little fade/shrink; grid reflows naturally
      if (isMobile()) {
        win.classList.add("removing");
        setTimeout(() => win.remove(), 140);
      } else {
        win.remove();
      }
    });

    win.addEventListener("pointerdown", () => bringToFront(win));

    body.addEventListener("click", openOverlay);
    body.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " ") openOverlay(e);
    });

    // minimize overlay
    minBtn.addEventListener("pointerdown", (e) => e.stopPropagation());
    minBtn.addEventListener("click", closeOverlay);

    // prevent overlay from triggering drag
    overlay.addEventListener("pointerdown", (e) => e.stopPropagation());
    overlay.addEventListener("click", (e) => e.stopPropagation());

    // Esc closes only if that overlay is open
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && overlay.classList.contains("active")) closeOverlay(e);
    });

    // Drag ONLY from titlebar (DESKTOP ONLY) — your existing behavior
    bar.addEventListener("pointerdown", (e) => {
      if (isMobile()) return; // mobile grid: no drag
      if (e.target === close) return;
      if (overlay.classList.contains("active")) return;

      e.preventDefault();
      bringToFront(win);

      const rectDesk = desktop.getBoundingClientRect();
      const rectWin = win.getBoundingClientRect();

      const startX = e.clientX;
      const startY = e.clientY;

      const startLeft = rectWin.left - rectDesk.left;
      const startTop  = rectWin.top  - rectDesk.top;

      win.setPointerCapture(e.pointerId);

      function onMove(ev) {
        const dx = ev.clientX - startX;
        const dy = ev.clientY - startY;

        const nextLeft = startLeft + dx;
        const nextTop  = startTop + dy;

        // NO snapping. NO clamping. Pure gremlin freedom (as requested earlier).
        win.style.left = nextLeft + "px";
        win.style.top  = nextTop + "px";

        // persist position (so if you resize then return to desktop mode)
        win.dataset.x = String(nextLeft);
        win.dataset.y = String(nextTop);
      }

      function onUp() {
        try { win.releasePointerCapture(e.pointerId); } catch (_) {}
        win.removeEventListener("pointermove", onMove);
        win.removeEventListener("pointerup", onUp);
        win.removeEventListener("pointercancel", onUp);
      }

      win.addEventListener("pointermove", onMove);
      win.addEventListener("pointerup", onUp);
      win.addEventListener("pointercancel", onUp);
    });

    return win;
  }

function populate() {
  desktop.innerHTML = "";

  const wins = PRACTICE.map(item => {
    const w = createWindow(item);
    desktop.appendChild(w);
    return w;
  });

  // Let layout settle before we measure + place (prevents bad clamping / weird stacks)
  const placeDesktop = () => {
    if (isMobile()) {
      syncModeClass();
      return;
    }

    const positions = computeSplayPositions(wins.length);
    wins.forEach((win, i) => {
      win.dataset.x = String(positions[i].x);
      win.dataset.y = String(positions[i].y);
      applyDesktopPosition(win);
    });

    syncModeClass();
  };

  // 2 RAFs makes this resilient to late layout shifts (video/font)
  requestAnimationFrame(() => requestAnimationFrame(placeDesktop));
}

  resetBtn.addEventListener("click", populate);
  populate();

  // On resize/orientation: only switch mode; do not re-splay unless reset is pressed.
  let resizeTimer = null;
  window.addEventListener("resize", () => {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(syncModeClass, 120);
  });

  // Some browsers support matchMedia change
  mqMobile.addEventListener?.("change", syncModeClass);
})();
  </script>

</body>
</html>
