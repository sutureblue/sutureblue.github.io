<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>hello there.</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="styles.css" />
  <link rel="icon" href="assets/favicon.png" type="image/png" />
</head>

<body>
 <div id="pixelLinks" aria-hidden="true"></div>
      <div class="page">

    <div class="top">
      <header class="site-header">
        <video class="header-image" autoplay muted loop playsinline>
          <source src="assets/icon.webm" type="video/webm">
          <source src="assets/icon.mp4" type="video/mp4">
        </video>
      </header>

      <section class="hero">
        <h1>Bee Nix // Suture Blue</h1>
        <p>Thinking. Creating. Playing.</p>
        <p>Animations. Interactives. Games. Lectures.</p>
      </section>
    </div>

    <main>

      <!-- PRACTICE -->
      <section id="practice" class="section">
        <h2></h2> <!--this is where you can add text above carousel if you want -->

        <!-- Carousel -->
        <div class="work-item">
          <div class="glow-card">
            <div class="glow-card-inner">

              <div class="carousel">
                <button class="carousel-btn left" type="button" aria-label="Previous project">‹</button>

                <div class="carousel-stage">
                  <div class="carousel-stack left"></div>

                  <div class="carousel-center" role="button" tabindex="0" aria-label="Open project details">
                    <img class="carousel-center-img" src="assets/gNg.png" alt="">
                  </div>

                  <div class="carousel-stack right"></div>
                </div>

                <button class="carousel-btn right" type="button" aria-label="Next project">›</button>

                <div class="carousel-sources" hidden>
                  <img src="assets/glitchplay.png" data-title="Glitch Play (2025)" data-template=".tpl-glitchplay" alt="">
                  <img src="assets/gNg.png"        data-title="Glitch'N'Games (2024)" data-template=".tpl-gng" alt="">
                  <img src="assets/mfru.png"       data-title="MFRU (2023)" data-template=".tpl-mfru" alt="">
                  <img src="assets/shadesOfPrecision.png"       data-title="Shades Of Precision (2023)" data-template=".tpl-shadesOfPrecision" alt="">
                  <img src="assets/notGlitch.png"       data-title="/NOT.GLI.TCH/H (2023)" data-template=".tpl-notGlitch" alt="">
                  <img src="assets/hereWeAre.png"       data-title="Here We Are (2022)" data-template=".tpl-hereWeAre" alt="">
                </div>

                <div class="work-overlay" aria-hidden="true" role="dialog" aria-modal="true">
                  <div class="overlay-inner">
                    <div class="overlay-scroll">
                      <div class="overlay-text"></div>
                    </div>

                    <div class="overlay-actions">
                      <button class="overlay-close" type="button" aria-label="Close overlay">×</button>
                    </div>
                  </div>
                </div>

              </div><!-- /.carousel -->

            </div>
          </div>

          <div class="work-meta">
            <h3 class="project-title"></h3>
          </div>

          <!-- Carousel templates -->
          <template class="tpl-glitchplay">
            <p>
              Glitch Play is my MFA thesis in Interactive Media and Game Development. It investigates engaging with glitches as a form of play that reveals and enables the ability to renegotiate with the structure of digital systems.
              You can <a href="https://archive.org/details/glitch_play" target="_blank" rel="noreferrer">read it here.</a>
            </p>
          </template>

          <template class="tpl-gng">
            <p>
              This exhibition explored the intertwined histories of glitch art and video games, featuring 40+ artists from over 5 countries, across two Pittsburgh venues.
            </p>
            <p>
              As producer, curator, and organizer alongside John Bumstead and Nick Liberatore, I developed the show's conceptual framework and programmed workshops, discussions, and live demonstrations.
            </p>
            <p>
              I created and moderated the Discussion Game, a participatory conversation format that gathered artists, theorists, and gamers to explore themes of play, control, and system disruption.
            </p>
          </template>

          <template class="tpl-mfru">
            <p>
              This panel of digital artists was brought together in Maribor, Slovenia to discuss digital archiving for community by community for
              <a href="https://www.mfru.org/events/panel-sustainability-and-autonomy-of-digital-art" target="_blank" rel="noreferrer">MFRU 2023.</a>
            </p>
            <p>
              My IRL contributions to the discussion were not so much about my experience as an artist, but rather as a Do-It-Together (DIT) media archivist who is currently organizing, with a couple others— a free, downloadable, public access digital archive for the Glitch Art community.
            </p>
            <p>
              Those of us working on this project believe that the more you rely on open software, the more accessible an archive becomes. That community projects can operate with more integrity when they remain unaffiliated with any institution(s). And most of all, we actively go against writing any “defining narrative(s),” but rather aim to offer an index of searchable artists and artists’ works, as well as any affiliated history, to enable many narratives to overlap, web and be formed by people of the community, in hopes for a more holistic history to be available to those who care to have it.
            </p>
          </template>

          <template class="tpl-shadesOfPrecision">
            <p>
              I was asked to review a self-curated selection from the <a href="https://fubar.space/2023/shades-of-precision/" target="_blank" rel="noreferrer">2023 /'FU:BAR/ EXPO.</a> To challenge my own biases, I read only each artist's description before viewing their work, hoping connections would emerge organically. Several pieces focused on control and deliberacy, a theme that felt especially compelling in the context of glitches. It was rewarding to discover that many of my selections came from artists I already admire.
            </p>
            <p>
              The exhibition reveals precision and chaos as collaborators. From Tomasz Sulej's meticulous GLIC codec to APIACOAB's pixel-perfect narratives, deliberate control amplifies disorder, transforming glitches into intentional expression. Every pixel, every distortion, an authentic creation in the digital realm.
            </p>
          </template>
          
          <template class="tpl-notGlitch">
            <p>
              /NOT.GLI.TCH/H was held at the University of Chicago. I presented a talk about online community through the lens of my involvement with Glitch Artists Collective (GAC), likely the world’s largest Glitch Art community.
            </p>
            <p>
              GAC was established in 2013 on Facebook first (though is also on Instagram, Twitter, and Tumblr) and I initially became involved as an artist near the end of 2014, later becoming curator, which I still am, and occasionally an admin. My talk discussed the aesthetic evolutions of glitch within the community, what questions the community concerns/ed themselves with, the importance of earnest connection + IRL gatherings, and the protective trust based + open-source principles that sets GAC apart from other internet communities.
            </p>
          </template>
          
         <template class="tpl-hereWeAre">
            <p>
              This discussion was had during the third iteration of GlitchArtIsDead, first shown in Poland in 2015. I was one of the main organizers and curators for GAID III, which featured just over 100 artists from 13 countries, and received a grant from the Southwest Minnesota Arts Council. I moderated this roundtable discussion with Dr. Michael Betancourt, an artist curated into the show whom I asked to also lead this discussion, along with others, including Jamie Fenton, John Bumstead, Aleksandra Pieńkosz, Sabato Visconti, Kaspar Ravel, Sky Goodman and more. The conversation traced glitch art's evolution from 1980s-90s technical accidents to intentional symbolic works that challenge digital boundaries. Participants shared personal experiences with digital disruptions and explored how Glitch Art addresses themes of authenticity, community values, and resistance to commercial frameworks. We examined the physical materiality of digital art and discussed how the movement builds creative resilience within increasingly regulated digital landscapes.
            </p>
           <p>
             <a href="assets/HereWeAre_GAID3_2022.pdf" target="_blank" rel="noreferrer">Read the text script for "Here We Are"</a>
           </p>
           <p>
             Photo taken by <a href="https://www.instagram.com/platinumjimjam/" target="_blank" rel="noreferrer">Jim Jam</a>
           </p>
       </template>
        </div>

        <!-- Reset button BELOW carousel -->
        <div class="practice-controls">
          <button id="practiceReset" class="practice-reset" type="button" aria-label="Reset practice windows" title="Reset">↺</button>
            <span class="practice-label">Practice</span>
        </div>

        <!-- Starting area BELOW reset -->
        <div id="practiceDesktop" class="practice-desktop" aria-label="Draggable practice windows">
          <!-- windows injected by JS -->
        </div>

        <!-- Practice text templates -->
        <template id="tpl-colourorgan">
          <p>Colour Organ is a digital implementation of Alexander Wallace Rimington's color-music theory, where audio frequencies trigger corresponding colored lights arranged in a 5x7 grid representing octaves and scales. The installation backlit a semi-translucent screen with 35 individual point lights programmed to respond to specific frequency ranges, creating a visual orchestration of the ROYGBIV spectrum synchronized to sound.</p>
        </template>

        <template id="tpl-discussiongame">
          <p>Discussion Game was a participatory conversation game that I developed and moderated for Glitch'N'Games’24. Featuring artists, theorists, and gamers including Jamie Fenton, Nick Briz, Sabato Visconti, Kaspar Ravel, and more, the conversation used prompt cards to guide an open-ended dialogue on glitch, control, and play. Topics ranged from quantum logic to surveillance culture, pedagogical theory to personal glitch histories. Rather than defining the glitch, the session treated it as a generative lens—where system instability became a site for shared interpretation, critique, and improvisation.</p>
          <p>
             <a href="assets/gNg_DiscussionGame_BeeNix2024.pdf" target="_blank" rel="noreferrer">Read the text script for "Discussion Game"</a>
          </p>
          <p>Photo taken by <a href="http://nickbriz.com/" target="_blank" rel="noreferrer">Nick Briz</a></p>
        </template>

        <template id="tpl-uncanny">
          <p>An Uncanny Scene is a virtual environment exploring the aesthetic of curious discomfort, where familiar elements become estranged and eerie.</p>
        </template>

        <template id="tpl-drawing">
          <p>Since 2014, I’ve created looping rotoscoped animations intended to hold a viewer in an evocative moment of intra/interpersonal reflections. These animations are often combined with analog & digital glitch techniques as methodological expressions of engaging as an interpretive system within systems. Positioning myself (and by extension a viewer) as an interpreter embedded within larger systemic boundaries and ruptures.</p>
          <p>Naturally, I also draw still images from time to time too.</p>
        </template>

        <template id="tpl-fabrication">
          <p>Most people know me for my digital/analog works, though since 2016, my fabrication practice has been my primary job. I've grown from supporting others’ projects to independently leading design/build work. My experience bridges traditional craft and modern digital tools, allowing me to translate ideas into durable, interactive pieces across a range of contexts.</p>
        </template>

        <template id="tpl-lightsleeper">
          <p><a href="https://www.youtube.com/watch?v=R0VyONd6Eko" target="_blank" rel="noreferrer">Light Sleeper, Heavy Dreamer</a> was a collaborative live performance with <a href="https://royb0t.bandcamp.com/" target="_blank" rel="noreferrer">royb0t</a> exploring memory through glitched digital landscapes and otherworldly music. The interactive piece guided audiences through dream-like environments, combining visual breaks with atmospheric sound.</p>
        </template>

      </section>

      <!-- About -->
      <section id="about" class="section">
        <h2>About</h2>

        <div class="about-layout">
          <div>
            <p>I’m Bee Nix, aka Suture Blue.</p>
            <p>
              As a system amongst systems, I trace how internal states entangle with
              the larger technosocial worlds by interweaving play, technology, and social structures.
              Time-based and experiential works tend to be what I make the most.
            </p>

            <!-- CV button -->
            <a class="cv-link" href="assets/BeeNix_CV_2026.pdf" target="_blank" rel="noreferrer">View CV</a>
          </div>

          <div class="about-meta">
            <p>
              <strong>Currently</strong><br>
              Residing in Pittsburgh, PA;
              Working in the exhibits department at the Children's Museum as a designer/builder;
              Slowly making this website; Practicing maintaining center; Trying to get Glitch'N'Games 2 going;
              Creating art, curating things, talking to others.
            </p>

            <p>
              <strong>Contact</strong><br>
              sutureblue@protonmail.com
            </p>
          </div>
        </div>
      </section>

    </main>

    <footer class="site-footer">
      <div class="license-footer">
        <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noreferrer">
          <img src="assets/cc.png" alt="Creative Commons" class="cc-icon" />
        </a>
        <span>2025</span>
      </div>

      <span class="footer-note">designed & vibe-coded · Hosted on GitHub Pages · gently under construction</span>
    </footer>

  </div>

  <script>
    /* ---------- Carousel + Overlay (UNCHANGED from your original) ---------- */
    document.querySelectorAll(".work-item").forEach((workItem) => {
      const carousel = workItem.querySelector(".carousel");

      const overlay = workItem.querySelector(".work-overlay");
      const overlayInner = workItem.querySelector(".overlay-inner");
      const overlayScroll = workItem.querySelector(".overlay-scroll");
      const overlayText = workItem.querySelector(".overlay-text");

      const closeBtn = workItem.querySelector(".overlay-close");

      const titleEl = workItem.querySelector(".project-title");

      const centerImg = carousel.querySelector(".carousel-center-img");
      const centerArea = carousel.querySelector(".carousel-center");

      const leftStackEl = carousel.querySelector(".carousel-stack.left");
      const rightStackEl = carousel.querySelector(".carousel-stack.right");

      const btnLeft = carousel.querySelector(".carousel-btn.left");
      const btnRight = carousel.querySelector(".carousel-btn.right");

      let lastFocusEl = null;

      const projects = Array.from(
        carousel.querySelectorAll(".carousel-sources img")
      ).map(img => ({
        src: img.getAttribute("src"),
        title: img.dataset.title || "Untitled",
        template: img.dataset.template || ""
      }));

      let center = 0;
      let leftStack = [];
      let rightStack = projects.map((_, i) => i).slice(1);

      function updateMeta(index) {
        titleEl.textContent = projects[index].title;
        const sel = projects[index].template;
        const tpl = sel ? workItem.querySelector(sel) : null;
        overlayText.innerHTML = tpl ? tpl.innerHTML : "";
      }

      function renderStacks() {
        leftStackEl.innerHTML = "";
        rightStackEl.innerHTML = "";

        leftStack.forEach((idx, i) => {
          const card = document.createElement("div");
          card.className = "stack-card";
          card.style.setProperty("--stack-i", i);
          card.innerHTML = `<img src="${projects[idx].src}" alt="">`;
          leftStackEl.appendChild(card);
        });

        rightStack.forEach((idx, i) => {
          const card = document.createElement("div");
          card.className = "stack-card";
          card.style.setProperty("--stack-i", i);
          card.innerHTML = `<img src="${projects[idx].src}" alt="">`;
          rightStackEl.appendChild(card);
        });

        centerImg.src = projects[center].src;
        updateMeta(center);

        btnLeft.disabled = leftStack.length === 0;
        btnRight.disabled = rightStack.length === 0;
      }

      function goNext() {
        if (!rightStack.length) return;
        leftStack.unshift(center);
        center = rightStack.shift();
        renderStacks();
      }

      function goPrev() {
        if (!leftStack.length) return;
        rightStack.unshift(center);
        center = leftStack.shift();
        renderStacks();
      }

      btnLeft.onclick = goPrev;
      btnRight.onclick = goNext;

      function openOverlay(e) {
        if (e) e.stopPropagation();
        lastFocusEl = document.activeElement;

        overlay.classList.add("active");
        overlay.setAttribute("aria-hidden", "false");
        overlayScroll.scrollTop = 0;

        closeBtn.focus({ preventScroll: true });
      }

      function closeOverlay(e) {
        if (e) e.stopPropagation();
        overlay.classList.remove("active");
        overlay.setAttribute("aria-hidden", "true");
        if (lastFocusEl) lastFocusEl.focus({ preventScroll: true });
      }

      centerArea.onclick = openOverlay;
      
      titleEl.style.cursor = "pointer";
      titleEl.onclick = openOverlay;

      centerArea.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") openOverlay(e);
      });

      closeBtn.onclick = closeOverlay;
      overlay.onclick = closeOverlay;
      overlayInner.onclick = (e) => e.stopPropagation();

      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape") closeOverlay(e);
      });

      renderStacks();
    });

/* ---------- Practice Windows
   Desktop: draggable windows + right-splayed randomized zig-zag spawn (like your screenshot)
   Mobile: 2-col grid; close removes tile and grid reflows; reset repopulates.
---------- */
(() => {
  const desktop = document.getElementById("practiceDesktop");
  const resetBtn = document.getElementById("practiceReset");
  if (!desktop || !resetBtn) return;

  const PRACTICE = [
    { id:"drawing",        src:"assets/Drawing_1.png",        title:"Animations & Drawings" },
    { id:"fabrication",    src:"assets/Fabrication_1.png",    title:"Fabrication" },
    { id:"lightsleeper",   src:"assets/LightSleeper_1.png",   title:"Light Sleeper, Heavy Dreamer (2020)" },
    { id:"colourorgan",    src:"assets/ColourOrgan_1.png",    title:"Colour Organ (2021)" },
    { id:"uncanny",        src:"assets/Uncanny_1.png",        title:"An Uncanny Scene (2022)" },
    { id:"discussiongame", src:"assets/DiscussionGame_1.png", title:"Discussion Game (2024)" },
  ];

  const mqMobile = window.matchMedia("(max-width: 760px)");
  const isMobile = () => mqMobile.matches;

  let zTop = 10;

  function getTemplateHTML(id) {
    const tpl = document.getElementById(`tpl-${id}`);
    return tpl ? tpl.innerHTML : `<p><strong>${id}</strong></p>`;
  }

  function bringToFront(win) {
    win.style.zIndex = String(++zTop);
  }

  function randBetween(min, max) {
    return min + Math.random() * (max - min);
  }

  function clamp(n, min, max) {
    return Math.max(min, Math.min(max, n));
  }

  // Compute right-splayed zig-zag spawn positions for DESKTOP mode
  function computeSplayPositions(count) {
    // Use known default window dimensions on desktop (your CSS defaults)
    const WIN_W = 300;
    const BAR_H = 34;
    const IMG_H = 250;
    const WIN_H = BAR_H + IMG_H;

    // Ensure desktop has a measurable rect (in case of first load)
    const rect = desktop.getBoundingClientRect();
    const deskW = Math.max(320, rect.width || 320);
    const deskH = Math.max(520, rect.height || 520);

    // You can tune these to taste
    const startX  = 30;
    const startY  = 24;
    const stepX   = 140; // splay right
    const stepY   = 10;  // gentle descent
    const zigAmp  = 26;  // up/down swing
    const jitterX = 14;  // slight hand-placed feel
    const jitterY = 10;

    // bounds: avoid starting in the void
    const minX = 8;
    const minY = 8;
    const maxX = Math.max(minX, Math.floor(deskW - WIN_W - 8));
    const maxY = Math.max(minY, Math.floor(deskH - WIN_H - 8));

    const pos = [];

    for (let i = 0; i < count; i++) {
      const zig = (i % 2 === 0) ? -zigAmp : zigAmp;

      let x = startX + i * stepX + randBetween(-jitterX, jitterX);
      let y = startY + i * stepY + zig + randBetween(-jitterY, jitterY);

      // clamp so they're visible initially
      x = clamp(x, minX, maxX);
      y = clamp(y, minY, maxY);

      pos.push({ x, y });
    }

    return pos;
  }

  function applyDesktopPosition(win) {
    const x = parseFloat(win.dataset.x || "0");
    const y = parseFloat(win.dataset.y || "0");
    win.style.left = x + "px";
    win.style.top  = y + "px";
  }

  function applyMobilePosition(win) {
    // Grid places it; remove absolute offsets
    win.style.left = "";
    win.style.top = "";
  }

  function syncModeClass() {
    if (isMobile()) desktop.classList.add("is-mobile");
    else desktop.classList.remove("is-mobile");

    const wins = Array.from(desktop.querySelectorAll(".pwin"));
    wins.forEach(win => {
      if (isMobile()) applyMobilePosition(win);
      else applyDesktopPosition(win);
    });
  }

  function createWindow(item) {
    const win = document.createElement("div");
    win.className = "pwin";
    win.dataset.id = item.id;
    win.style.zIndex = String(++zTop);

    // placement happens after creation (populate assigns x/y)
    win.innerHTML = `
      <div class="pwin-bar" role="toolbar">
        <button class="pwin-close" type="button" aria-label="Close window">×</button>
        <div class="pwin-title" title="${item.title}">${item.title}</div>
      </div>

      <div class="pwin-body" role="button" tabindex="0" aria-label="Open description">
        <img src="${item.src}" alt="${item.title}">
      </div>

      <div class="pwin-overlay" aria-hidden="true">
        <button class="pwin-min" type="button" aria-label="Minimize description">–</button>
        <div class="pwin-overlay-scroll">
          <div class="pwin-overlay-text"></div>
        </div>
      </div>
    `;

    const bar = win.querySelector(".pwin-bar");
    const close = win.querySelector(".pwin-close");
    const body = win.querySelector(".pwin-body");

    const overlay = win.querySelector(".pwin-overlay");
    const minBtn = win.querySelector(".pwin-min");
    const overlayScroll = win.querySelector(".pwin-overlay-scroll");
    const overlayText = win.querySelector(".pwin-overlay-text");

    function openOverlay(e) {
      if (e) e.stopPropagation();
      bringToFront(win);

      overlayText.innerHTML = getTemplateHTML(item.id);
      overlay.classList.add("active");
      overlay.setAttribute("aria-hidden", "false");
      overlayScroll.scrollTop = 0;

      minBtn.focus({ preventScroll: true });
    }

    function closeOverlay(e) {
      if (e) e.stopPropagation();
      overlay.classList.remove("active");
      overlay.setAttribute("aria-hidden", "true");
    }

    // Close window
    close.addEventListener("click", (e) => {
      e.stopPropagation();

      // In mobile grid, do a little fade/shrink; grid reflows naturally
      if (isMobile()) {
        win.classList.add("removing");
        setTimeout(() => win.remove(), 140);
      } else {
        win.remove();
      }
    });

    win.addEventListener("pointerdown", () => bringToFront(win));

    body.addEventListener("click", openOverlay);
    body.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " ") openOverlay(e);
    });

    // minimize overlay
    minBtn.addEventListener("pointerdown", (e) => e.stopPropagation());
    minBtn.addEventListener("click", closeOverlay);

    // prevent overlay from triggering drag
    overlay.addEventListener("pointerdown", (e) => e.stopPropagation());
    overlay.addEventListener("click", (e) => e.stopPropagation());

    // Esc closes only if that overlay is open
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && overlay.classList.contains("active")) closeOverlay(e);
    });

    // Drag ONLY from titlebar (DESKTOP ONLY) — your existing behavior
    bar.addEventListener("pointerdown", (e) => {
      if (isMobile()) return; // mobile grid: no drag
      if (e.target === close) return;
      if (overlay.classList.contains("active")) return;

      e.preventDefault();
      bringToFront(win);

      const rectDesk = desktop.getBoundingClientRect();
      const rectWin = win.getBoundingClientRect();

      const startX = e.clientX;
      const startY = e.clientY;

      const startLeft = rectWin.left - rectDesk.left;
      const startTop  = rectWin.top  - rectDesk.top;

      win.setPointerCapture(e.pointerId);

      function onMove(ev) {
        const dx = ev.clientX - startX;
        const dy = ev.clientY - startY;

        const nextLeft = startLeft + dx;
        const nextTop  = startTop + dy;

        // NO snapping. NO clamping. Pure gremlin freedom
        win.style.left = nextLeft + "px";
        win.style.top  = nextTop + "px";

        // persist position (so if you resize then return to desktop mode)
        win.dataset.x = String(nextLeft);
        win.dataset.y = String(nextTop);
      }

      function onUp() {
        try { win.releasePointerCapture(e.pointerId); } catch (_) {}
        win.removeEventListener("pointermove", onMove);
        win.removeEventListener("pointerup", onUp);
        win.removeEventListener("pointercancel", onUp);
      }

      win.addEventListener("pointermove", onMove);
      win.addEventListener("pointerup", onUp);
      win.addEventListener("pointercancel", onUp);
    });

    return win;
  }

function populate() {
  desktop.innerHTML = "";

  const wins = PRACTICE.map(item => {
    const w = createWindow(item);
    desktop.appendChild(w);
    return w;
  });

  // Let layout settle before we measure + place (prevents bad clamping / weird stacks)
  const placeDesktop = () => {
    if (isMobile()) {
      syncModeClass();
      return;
    }

    const positions = computeSplayPositions(wins.length);
    wins.forEach((win, i) => {
      win.dataset.x = String(positions[i].x);
      win.dataset.y = String(positions[i].y);
      applyDesktopPosition(win);
    });

    syncModeClass();
  };

  // 2 RAFs makes this resilient to late layout shifts (video/font)
  requestAnimationFrame(() => requestAnimationFrame(placeDesktop));
}

  resetBtn.addEventListener("click", populate);
  populate();

  // On resize/orientation: only switch mode; do not re-splay unless reset is pressed.
  let resizeTimer = null;
  window.addEventListener("resize", () => {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(syncModeClass, 120);
  });

  // Some browsers support matchMedia change
  mqMobile.addEventListener?.("change", syncModeClass);
})();

    

    /* ---------- Pixel Links ---------- */
  (() => {
  const layer = document.getElementById("pixelLinks");
  if (!layer) return;

  // Add your extra projects here
  const EXTRA = [
    { href: "https://www.youtube.com/live/q7vPZkCKukQ", label: "Slowrun /fu:bar/ 2021" },
    { href: "https://www.youtube.com/watch?v=tWp3CEuwzdE", label: "Totally not a Speedrun /’fubar/ 2o22" },
    { href: "https://www.youtube.com/watch?v=u7pGPptqkjs", label: "A.I. and Online Communities" },
    { href: "https://youtu.be/2FZ3mJfzuf0?si=Zpk4Jbf2mxt8pVf-", label: "Gork" },
    { href: "https://youtu.be/pT5MtQJTCVA", label: "Scanlines.xyz" },
  ];

  const COLORS = ["#17a2b8", "#7fd3e0", "#b7ff5a", "#ff4fd8", "#ffd24f", "#7a5cff"];

  // “avoid” targets (only these)
  const AVOID_SELECTORS = [".carousel", ".about-meta"];

  // Tune these
  const RELOCATE_MS = 30000;
  const AVOID_PADDING = 18;      // extra breathing room around avoided areas
  const PIXEL_SIZE = 6;
  const COUNT_DESKTOP = 5;
  const COUNT_MOBILE = 5;

  const rand = (min, max) => min + Math.random() * (max - min);
  const pick = (arr) => arr[Math.floor(Math.random() * arr.length)];

  function clearPixels() {
    layer.innerHTML = "";
  }

  function getAvoidRects() {
    const rects = [];
    AVOID_SELECTORS.forEach(sel => {
      const el = document.querySelector(sel);
      if (!el) return;

      const r = el.getBoundingClientRect();

      // Skip if element is basically offscreen (helps avoid “ghost blocking”)
      const vw = window.innerWidth, vh = window.innerHeight;
      const offscreen =
        r.bottom < 0 || r.top > vh || r.right < 0 || r.left > vw;
      if (offscreen) return;

      rects.push({
        left: r.left - AVOID_PADDING,
        top: r.top - AVOID_PADDING,
        right: r.right + AVOID_PADDING,
        bottom: r.bottom + AVOID_PADDING
      });
    });
    return rects;
  }

  function pointInRect(x, y, r) {
    return x >= r.left && x <= r.right && y >= r.top && y <= r.bottom;
  }

  function safeSpot(x, y, avoidRects) {
    // check the pixel’s center point
    const cx = x + PIXEL_SIZE / 2;
    const cy = y + PIXEL_SIZE / 2;
    for (const r of avoidRects) {
      if (pointInRect(cx, cy, r)) return false;
    }
    return true;
  }

  function spawnPixels() {
    clearPixels();

    const vw = window.innerWidth;
    const vh = window.innerHeight;

    const avoidRects = getAvoidRects();

    const count = (vw <= 760) ? COUNT_MOBILE : COUNT_DESKTOP;

    // If there are no links, don’t create dead pixels (unless you want that vibe)
    if (!EXTRA.length) return;

    // Shuffle so which projects appear changes each cycle
    const shuffled = [...EXTRA].sort(() => Math.random() - 0.5);

    const maxAttemptsPerPixel = 120;

    for (let i = 0; i < count; i++) {
      const proj = shuffled[i % shuffled.length];

      let placed = false;

      for (let attempt = 0; attempt < maxAttemptsPerPixel; attempt++) {
        const x = rand(6, vw - (PIXEL_SIZE + 6));
        const y = rand(6, vh - (PIXEL_SIZE + 6));

        if (!safeSpot(x, y, avoidRects)) continue;

        const a = document.createElement("a");
        a.className = "pixel-link";
        a.href = proj.href;
        a.target = "_blank";
        a.rel = "noreferrer";
        a.title = proj.label;
        a.style.background = pick(COLORS);
        a.style.left = `${x}px`;
        a.style.top = `${y}px`;

        layer.appendChild(a);
        placed = true;
        break;
      }

      // If we failed to place (very small screens + big avoid zones), just skip that pixel.
      if (!placed) continue;
    }
  }

  // Respawn on resize and on scroll (scroll matters because avoid rects move)
  let t = null;
  function scheduleSpawn() {
    clearTimeout(t);
    t = setTimeout(spawnPixels, 80);
  }

  window.addEventListener("resize", scheduleSpawn, { passive: true });
  window.addEventListener("scroll", scheduleSpawn, { passive: true });

  // Relocate periodically
  setInterval(spawnPixels, RELOCATE_MS);

  spawnPixels();
})();
    
  </script>

</body>
</html>
